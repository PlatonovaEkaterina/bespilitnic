from controller import Robot
from controller import Motor
from controller import DistanceSensor
import math
import sys


TIME_STEP=32

robot = Robot()

timestep = int(robot.getBasicTimeStep())

ds = robot.getDistanceSensor('ds')
ds.enable(timestep)

MASS = 7.84
H_TARGET = 100.0
g = 7.30699
VELOCITY = math.sqrt(g * MASS) / 2
K_p = 0.001
K_d = -0.001


def comp_e(h_target):
    if ds.getValue() == 100000:
        return h_target
    return h_target - ds.getValue()


def set_velocity(v_now):
    global VELOCITY
    VELOCITY = math.sqrt(g * MASS) / 2 + K_p * comp_e(H_TARGET) + K_d * v_now

imu = robot.getInertialUnit('inertial unit')
imu.enable(timestep)

num_motor = sys.argv[1]
motor=robot.getMotor('lop_' + num_motor)
motor.setPosition(float('inf'))
motor.setVelocity(0.0)

d1 = 0

timeConstUp = 500
timeConstForward = 40
timeConstBack = 40

# Main loop:
while robot.step(timestep) != -1:
    
    alpha = imu.getRollPitchYaw()[1]
    
    d = ds.getValue()
    if d == 100000:
        d = 0
    
    set_velocity((d - d1) / 0.01)
    
    d1 = d
    
    if timeConstUp != 0:
        timeConstUp -= 1
    elif timeConstForward != 0:
        timeConstForward -= 1
    elif timeConstBack != 0:
        timeConstBack -= 1
       
    if timeConstUp == 0 and timeConstForward != 0:
        if num_motor == '1' or num_motor == '2':
            motor.setVelocity(VELOCITY * 0.999)
        else:
            motor.setVelocity(VELOCITY)
    elif timeConstUp == 0 and timeConstBack != 0:
        if num_motor == '3' or num_motor == '4':
            motor.setVelocity(VELOCITY * 0.999)
        else:
            motor.setVelocity(VELOCITY)
    else:
        motor.setVelocity(VELOCITY)
    
    
    #print(str(d) + ' ' + str(max_d) + ' ' + str(VELOCITY))
    print(str(timeConstUp) + ' ' + str(alpha) + ' ' + str(VELOCITY))
    
        d = 0
    
    set_velocity((d - d1) / 0.01)
    
    d1 = d
    
    if timeConstUp != 0:
        timeConstUp -= 1
    elif timeConstForward != 0:
        timeConstForward -= 1
       
    if timeConstUp == 0 and timeConstForward != 0 and (num_motor == '1' or num_motor == '2'):
            motor.setVelocity(VELOCITY * 0.999)
    else:
        motor.setVelocity(VELOCITY)
    
    
    #print(str(d) + ' ' + str(max_d) + ' ' + str(VELOCITY))
    print(str(timeConstUp) + ' ' + str(alpha) + ' ' + str(VELOCITY))
    
    
