from controller import Robot
from controller import Motor
from controller import DistanceSensor
import math
import sys


TIME_STEP=32

robot = Robot()

timestep = int(robot.getBasicTimeStep())

ds = robot.getDistanceSensor('ds')
ds.enable(timestep)

MASS = 7.84
H_TARGET = 100.0
g = 9.81
thrustConstants = 1.34255008
# Скорость вращения винтов, при которой квадрокптер зависнет в воздухе
# F = 4 * thrustConstants * VELOCITY ** 2 = MASS * g
VELOCITY_S = 0
ANGLE_BLADE_S = 0.785398 # math.pi / 4
VELOCITY_R = 3.6
ANGLE_BLADE_R = 0
# Ускорение вызываемое наклоном квадрокоптера вперед/назад
# при соотношении скоростей винтов 999/1000
ACCELERATION = 0.97875
# Ускорение вызываемое наклоном квадрокоптера влево/вправо
# при соотношении скоростей винтов 999/1000
ACCELERATION_SIDE = 1.468125
# Коэффициент пропорциональности
K_p = 0.001
# Коэффициент дифференцильный
K_d = -0.001


# Разница между реальной высотой и желаемой
def comp_e(h_target):
    if ds.getValue() == 100000:
        return h_target
    return h_target - ds.getValue()


# Задание угла атаки лопасти
def set_angle_blade(v_vertical):
    global ANGLE_BLADE_R
    # Арксинус дает нам угол, при котором квадрокоптер висит в воздухе
    ANGLE_BLADE_R = math.asin((math.sqrt(g * MASS / (4 * thrustConstants))) ** 2 / VELOCITY_R ** 2 * math.sin(ANGLE_BLADE_S)) + K_p * comp_e(H_TARGET) + K_d * v_vertical


imu = robot.getInertialUnit('inertial unit')
imu.enable(timestep)

TASK = sys.argv[1]
num_motor = TASK[0]
INDEX_TASK = 2
#print(TASK)
#print(TASK[INDEX_TASK])

motor=robot.getMotor('lop_' + num_motor)
motor.setPosition(float('inf'))
motor.setVelocity(0.0)

d1 = 0
move = ''

timeUp = 500
timeForward = 0
timeBack = 0
timeRight = 0
timeLeft = 0
timeWait = 0
# Время перед наклоном в обратную сторону для погашения скорости движения
timeWait_move = 0


# Функция исполнения движения вперед
def move_forward():
    global timeForward, timeWait_move, ANGLE_BLADE_R
    if timeForward != 0: 
        timeForward -= 1
        
    if timeForward != 0 and (num_motor == '1' or num_motor == '2'):
        ANGLE_BLADE_R *= 0.995
    timeWait_move = 8
    
    
# Функция исполнения движения назад
def move_back():
    global timeBack, timeWait_move, ANGLE_BLADE_R
    if timeBack != 0:
        timeBack -= 1
        
    if timeBack != 0 and (num_motor == '3' or num_motor == '4'):
        ANGLE_BLADE_R *= 0.995
    timeWait_move = 8

    
# Функция исполнения движения направо
def move_right():
    global timeRight, timeWait_move, ANGLE_BLADE_R
    if timeRight != 0: 
        timeRight -= 1
        
    if timeRight != 0 and (num_motor == '2' or num_motor == '4'):
        ANGLE_BLADE_R *= 0.995
    timeWait_move = 8
    
    
# Функция исполнения движения влево
def move_left():
    global timeLeft, timeWait_move, ANGLE_BLADE_R
    if timeLeft != 0:
        timeLeft -= 1
        
    if timeLeft != 0 and (num_motor == '1' or num_motor == '3'):
        ANGLE_BLADE_R *= 0.995
    timeWait_move = 8
    
    
# Функция задания движения вперед/назад
def set_time_straight(distance):
    global timeForward, timeBack, timeWait
    timeForward = round(math.sqrt(distance / ACCELERATION))
    timeBack = round(math.sqrt(distance / ACCELERATION))
    timeWait = 600
    
    
# Функция задания движения влево/вправо
def set_time_side(distance):
    global timeRight, timeLeft, timeWait
    timeRight = round(math.sqrt(distance / ACCELERATION_SIDE))
    timeLeft = round(math.sqrt(distance / ACCELERATION_SIDE))
    timeWait = 600
    

# Main loop:
while robot.step(timestep) != -1:
    
    alpha = imu.getRollPitchYaw()[1]
    
    d = ds.getValue()
    if d == 100000:
        d = 0
    
    set_angle_blade((d - d1) / 0.01)
    
    d1 = d

    # Подьем вверх
    if timeUp != 0:
        timeUp -= 1
    # Ждем
    elif timeWait != 0:
        timeWait -= 1
    # задаем направление движения
    else:
        # Вперед
        if TASK[INDEX_TASK] == 'f':
            distance = 0
            move = 'f'  
            INDEX_TASK += 1
            while TASK[INDEX_TASK] != ' ':
                distance *= 10
                distance += int(TASK[INDEX_TASK]) 
                INDEX_TASK += 1
            INDEX_TASK += 1
            set_time_straight(distance)
                
        elif TASK[INDEX_TASK] == 'b':
            distance = 0
            move = 'b'  
            INDEX_TASK += 1
            while TASK[INDEX_TASK] != ' ':
                distance *= 10
                distance += int(TASK[INDEX_TASK]) 
                INDEX_TASK += 1
            INDEX_TASK += 1
            set_time_straight(distance) 
            
        elif TASK[INDEX_TASK] == 'r':
            distance = 0
            move = 'r'  
            INDEX_TASK += 1
            while TASK[INDEX_TASK] != ' ':
                distance *= 10
                distance += int(TASK[INDEX_TASK]) 
                INDEX_TASK += 1
            INDEX_TASK += 1
            set_time_side(distance)
            
        elif TASK[INDEX_TASK] == 'l':
            distance = 0
            move = 'l'   
            INDEX_TASK += 1
            while TASK[INDEX_TASK] != ' ':
                distance *= 10
                distance += int(TASK[INDEX_TASK]) 
                INDEX_TASK += 1
            INDEX_TASK += 1
            set_time_side(distance)              
    
    # Исполняем движение
    # Вперед
    if timeWait_move != 0:
        timeWait_move -= 1    
    elif move == 'f':
        if timeForward != 0:
            move_forward()
        elif timeBack != 0:
            move_back()
    # Назад  
    elif move == 'b':
        if timeBack != 0:
            move_back()
        elif timeForward != 0:
            move_forward()
    elif move == 'r':
        if timeRight != 0:
            move_right()
        elif timeLeft != 0:
            move_left()
    elif move == 'l':
        if timeLeft != 0:
            move_left()
        elif timeRight != 0:
            move_right()

    VELOCITY_S = math.sqrt(VELOCITY_R ** 2 * math.sin(ANGLE_BLADE_R) / math.sin(ANGLE_BLADE_S))
    motor.setVelocity(VELOCITY_S)
    
    print(str(ANGLE_BLADE_R) + ' ' + str(VELOCITY_S))
    #print(timeWait)
    #print(str(timeForward) + ' ' + str(timeBack) + ' ' + str(VELOCITY))
    #print(str(d) + ' ' + str(max_d) + ' ' + str(VELOCITY))
    #print(str(timeUp) + ' ' + str(alpha) + ' ' + str(VELOCITY))
